<!DOCTYPE html>
<html>
    <head>
    <!-- Title -->
    
    <title>
        JavaScript引用类型 | JackerJay杂记
    </title>
    
    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">
    
    <!-- Meta & INfo -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="JackerJay">
    <meta name="description" content="学习成长路">
    <meta name="keywords" content="null">
    
    <!--iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">
    
    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="JackerJay杂记">
    
    <!-- The Open Graph protocol -->
    <meta property="og:url" content="https://jackerjay.github.io">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="JavaScript引用类型 | JackerJay杂记">
    <meta property="og:description" content="学习成长路">
    
     <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">
        
        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->
    
    <!-- Import CSS -->
    <link rel="stylesheet" href="/css/material.min.css">
    <link rel="stylesheet" href="/css/style.min.css">
    <!-- Config CSS -->


<!-- Other Styles -->
<style>
	body, html{
		font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
	}
	
    a{
        color: #00838F
    }
    
    .mdl-card__media,
    #search-label,
    #search-form-label:after,
    #scheme-Paradox .hot_tags-count,
    #scheme-Paradox .sidebar_archives-count,
    #scheme-Paradox .sidebar-colored .sidebar-header,
    #scheme-Paradox .sidebar-colored .sidebar-badge{
        background-color: #0097A7 !important
    }
    
	/* Sidebar User Drop Down Menu Text Color */
	#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
    #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus{
        color: #0097A7 !important
    }
    
    #post_entry-right-info,
    .sidebar-colored .sidebar-nav li:hover > a,
    .sidebar-colored .sidebar-nav li:hover > a i,
    .sidebar-colored .sidebar-nav li > a:hover,
    .sidebar-colored .sidebar-nav li > a:hover i,
    .sidebar-colored .sidebar-nav li > a:focus i,
    .sidebar-colored .sidebar-nav > .open > a,
    .sidebar-colored .sidebar-nav > .open > a:hover,
    .sidebar-colored .sidebar-nav > .open > a:focus,
    #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a{
        color: #0097A7 !important
    }
    
    .toTop{
        background: #757575 !important
    }
		
	.material-layout .material-post>.material-nav,
	.material-layout .material-index>.material-nav,
	.material-nav a{
		color: #757575;
	}
		
	#scheme-Paradox .MD-burger-layer {
		background-color: #757575;
	}

	#scheme-Paradox #post-toc-trigger-btn{
		color: #757575;
	}
	
	.post-toc a:hover{
		color: #00838F;
		text-decoration: underline;
	}
</style>


<!-- Theme Background Related-->

    <style>
        body{
            background-color: #F5F5F5
        }
		
		/* blog_info bottom background */
        #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
            background-color: #fff;
        }
    </style>




<!-- Fade Effect -->

    <style>
        .fade {
            transition: all 800ms linear;
            -webkit-transform: translate3d(0,0,0);
            -moz-transform: translate3d(0,0,0);
            -ms-transform: translate3d(0,0,0);
            -o-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
            opacity: 1;
        }

        .fade.out{
            opacity: 0;
        }
    </style>

	<script src="/js/jquery.min.js"></script>
	
	<link rel="stylesheet" href="/css/highlight/solarized-white.css">
	
	<!-- UC Browser Compatible-->
	<script>
		var agent = navigator.userAgent.toLowerCase();
		if(agent.indexOf('ucbrowser')>0) {
			document.write('<link rel="stylesheet" href="/css/uc.css">');
		   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
		}
	</script>
    <!-- Hotjar Tracking Code for http://jackerjay.cc -->
    <script>
			(function(h,o,t,j,a,r){
				h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
				h._hjSettings={hjid:478398,hjsv:5};
				a=o.getElementsByTagName('head')[0];
				r=o.createElement('script');r.async=1;
				r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
				a.appendChild(r);
			})(window,document,'//static.hotjar.com/c/hotjar-','.js?sv=');
    </script>
    
    <!-- Custom Head -->
    
</head>
	
	

    <body id="scheme-Paradox">

		
        <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
				
			
			
            <!-- Main Container -->
            <main class="material-layout__content" id="main">
				
                <!-- Top Anchor -->
                <div id="top"></div>
				
				
                <!-- Hamburger Button -->
                <button class="MD-burger-icon sidebar-toggle">
                    <span class="MD-burger-layer"></span>
                </button>
				
				
                
	<!-- Back Button -->
<!--
	<div class="material-back" id="backhome-div" tabindex="0">
		<a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" href="#" onclick="window.history.back();return false;" target="_self" role="button" data-upgraded=",MaterialButton,MaterialRipple">
			<i class="material-icons" role="presentation">arrow_back</i>
			<span class="mdl-button__ripple-container">
				<span class="mdl-ripple"></span>
			</span>
		</a>
	</div>			
-->
	<!-- Left aligned menu below button -->
	<button id="post-toc-trigger-btn"
			class="mdl-button mdl-js-button mdl-button--icon">
	  <i class="material-icons">format_list_numbered</i>
	</button>

	<ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect"
		for="post-toc-trigger-btn">
			
			<ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#引用类型"><span class="post-toc-number">1.</span> <span class="post-toc-text">引用类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Object类型"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Object类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Array类型"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Array类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#检测数组"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">检测数组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#转换方法"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">转换方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#栈方法"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">栈方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#队列方法"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">队列方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#重排序方法"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">重排序方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#操作方法"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">操作方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#位置方法"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">位置方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#迭代方法"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">迭代方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缩小方法"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">缩小方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Date类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">Date类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#继承的方法"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">继承的方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#日期格式化方法"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">日期格式化方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RegExp类型"><span class="post-toc-number">3.</span> <span class="post-toc-text">RegExp类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RegExp实例属性"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">RegExp实例属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RegExp实例方法"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">RegExp实例方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RegExp构造函数属性"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">RegExp构造函数属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Function类型"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">Function类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#没有重载"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">没有重载</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#函数声明与函数表达式"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">函数声明与函数表达式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#作为值的函数"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">作为值的函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#函数内部属性"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">函数内部属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#函数属性和方法"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">函数属性和方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基本包装类型"><span class="post-toc-number">4.</span> <span class="post-toc-text">基本包装类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Boolean类型"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Boolean类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Number类型"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Number类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#String类型"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">String类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#字符方法"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">字符方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#字符串操作方法"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">字符串操作方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#字符串位置方法"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">字符串位置方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#trim-方法"><span class="post-toc-number">4.3.4.</span> <span class="post-toc-text">trim()方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#字符串大小写转换方法"><span class="post-toc-number">4.3.5.</span> <span class="post-toc-text">字符串大小写转换方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#字符串的模式匹配方法"><span class="post-toc-number">4.3.6.</span> <span class="post-toc-text">字符串的模式匹配方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#localeCompare-方法"><span class="post-toc-number">4.3.7.</span> <span class="post-toc-text">localeCompare()方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#fromCharCode-方法"><span class="post-toc-number">4.3.8.</span> <span class="post-toc-text">fromCharCode()方法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单体内置对象"><span class="post-toc-number">5.</span> <span class="post-toc-text">单体内置对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Global对象"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Global对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#URI编码方法"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">URI编码方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#eval-方法"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">eval()方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Global对象的属性"><span class="post-toc-number">5.1.3.</span> <span class="post-toc-text">Global对象的属性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#window对象"><span class="post-toc-number">5.1.4.</span> <span class="post-toc-text">window对象</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Math对象"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">Math对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Math对象的属性"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">Math对象的属性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#min-和max-方法"><span class="post-toc-number">5.2.2.</span> <span class="post-toc-text">min()和max()方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#舍入方法"><span class="post-toc-number">5.2.3.</span> <span class="post-toc-text">舍入方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#random-方法"><span class="post-toc-number">5.2.4.</span> <span class="post-toc-text">random()方法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#其他方法"><span class="post-toc-number">5.2.5.</span> <span class="post-toc-text">其他方法</span></a></li></ol></li></ol></li></ol>
		
<!--			<li class="mdl-menu__item">Some Action</li>-->
	</ul>


<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">
		
        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
	<!-- Paradox Post Header -->
	
		
			<!-- Random Thumbnail -->
			<div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
				<script>
    
    var randomNum;
    randomNum = Math.floor(Math.random() * 5 + 1);
    
    $(".post_thumbnail-random").css('background-image', 'url(' + '/img/random/' + randomNum + '.png' + ')');
    
</script>

		
	
        <p class="article-headline-p">
            JavaScript引用类型
        </p>
    </div>

	

				
				
					<!-- Paradox Post Info -->
					<div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">
    
    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>JackerJay</strong>
        <span>8月 17, 2017</span>
    </div>
    
    <div class="section-spacer"></div>
	
    <!-- Favorite -->
<!--
    <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
        <i class="material-icons" role="presentation">favorite</i>
        <span class="visuallyhidden">favorites</span>
    </button>
-->
    
    <!-- Tags (bookmark) -->
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/JavaScript基础/">JavaScript基础</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/基础学习/">基础学习</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/引用类型/">引用类型</a>
    </ul>
    
    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    
    
    
    
    
    <!-- Share Twitter -->
    <a class="post_share-link" href="https://twitter.com/intent/tweet?text=JavaScript引用类型&url=https://jackerjay.github.io//2017/08/17/JavaScript引用类型/index.html&via=JackerJay" target="_blank">
        <li class="mdl-menu__item">
            分享到 Twitter
        </li>
    </a>
    
    <!-- Share Google+ -->
    <a class="post_share-link" href="https://plus.google.com/share?url=https://jackerjay.github.io//2017/08/17/JavaScript引用类型/index.html" target="_blank">
        <li class="mdl-menu__item">
            分享到 Google+
        </li>
    </a>
    
    <!-- Share Weibo -->
    <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=JavaScript引用类型&url=https://jackerjay.github.io//2017/08/17/JavaScript引用类型/index.html&pic=&searchPic=false&style=simple" target="_blank">
        <li class="mdl-menu__item">
            分享到微博
        </li>
    </a>
</ul>
</div>
				

                <!-- Post Content -->
                <div id="post-content" class="markdown-Github mdl-color-text--grey-700 mdl-card__supporting-text fade out">
	
		<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a><code>Object</code>类型</h4><p>在使用<strong>对象字面量</strong>表示法来定义对象的时候，在最后一个属性后面添加逗号，会在**<code>IE7</code>及更早版本和<code>Opera</code>中导致错误`。<br>其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 以下两种声明方式是等价的</div><div class="line">var person = &#123;&#125;;</div><div class="line">var person = new Object();</div></pre></td></tr></table></figure>
<blockquote>
<p>在通过对象字面量定义对象时，实际上不会调用<code>Object</code>构造函数。  </p>
</blockquote>
<p>对象字面量也是向函数传递大量可选参数的首选方式。<br>从功能上来看，以下两种访问对象属性的方式没有任何区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person[&quot;name&quot;]);</div><div class="line">alert(person.name);</div></pre></td></tr></table></figure>
<p>但方括号语法的最主要优点是可以通过变量来访问属性。如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。  </p>
<blockquote>
<p>通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。</p>
</blockquote>
<h4 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a><code>Array</code>类型</h4><p><code>ECMAScript</code>中数组的每一项都可以保存任何类型的数据。而且，<code>ECMAScript</code>数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 使用`Array`构造函数创建数组：</div><div class="line">var colors = new Array();        // 创建一个空数组</div><div class="line">var colors = new Array(20);      // 创建一个`length`为20的数组</div><div class="line">var colors = new Array(&quot;Greg&quot;);  // 创建一个包含 1 项， 即字符串&quot;Greg&quot;的数组</div><div class="line"></div><div class="line">// 使用数组字面量表示法：</div><div class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">var names = [];                 // 创建一个空数组</div><div class="line"></div><div class="line">// !!!不建议的操作</div><div class="line">var values = [1, 2, ];       // 这样会创建一个包含 2 或 3 项的数组</div><div class="line">var options = [ , , , , , ]; // 这样会创建一个包含 5 或 6 项的数组</div></pre></td></tr></table></figure>
<blockquote>
<p>在<code>IE</code>中，上述<code>values</code>会成为一个包含 3 个项且每项的值分别为 1 、 2 和 <code>undefined</code> 的数组；在其他浏览器中，<code>values</code>会成为一个包含 2 项且值分别为 1 和 2 的数组。原因是在<code>IE8</code>及之前版本中的<code>ECMAScript</code>实现在数组字面量方面存在<code>bug</code>。<code>IE9</code>后修复了这个问题。我们强烈建议不要使用这种语法。<strong>与对象一样，在使用数组字面量表示法时，也不会调用<code>Array</code>构造函数（Firefox 3 及更早版本除外）</strong>。  </p>
<p>数组的项数保存在<code>length</code>属性中，这个属性<strong>不是只读的</strong>，可以通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。  </p>
<p>数组最多可以包含 4 294 967 295个项，在创建一个初始大小与这个上限值接近的数组，可能会导致运行时间超长的脚本错误。  </p>
</blockquote>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><p><strong>对于一个网页，或者一个全局作用域而言，使用<code>instanceof</code>操作符就能得到当前是否为数组</strong>。<br><strong><code>instanceof</code>操作符的问题在于，它假定单一的全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的<code>Array</code>构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，<code>ECMAScript 5</code>中新增了<code>Array.isArray()</code>方法。</strong> </p>
<blockquote>
<p>支持<code>Array.isArray()</code>方法的浏览器有<code>IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome</code>。  </p>
</blockquote>
<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><p>调用数组的<code>toString()</code>方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用<code>valueOf()</code>返回的还是数组。<strong>实际上，为了创建这个字符串会调用数组每一项的<code>toString()</code>方法。</strong><br><strong>当调用数组的<code>toLocaleString()</code>方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的<code>toLocaleString()</code>方法。</strong><br><strong>使用<code>join()</code>方法可以使用不同的分隔符来构建这个字符串。<code>join()</code>方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</strong><br><strong>如果不给<code>join()</code>方法传入任何职，或者给它传入<code>undefined</code>，则使用逗号作为分隔符。<em><code>IE7</code>及更早版本会错误的使用字符串”undefined”作为分隔符</em>。</strong>  </p>
<blockquote>
<p>如果数组中的某一项的值是<code>null</code>或者<code>undefined</code>，那么该值在<code>join()、toLocaleString()、toString()和valueOf()</code>方法返回的结果中以<em>空字符串</em>表示。  </p>
</blockquote>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>LIFO(Last-In-First-Out，后进先出)，<code>ECMAScript</code>提供了<code>push()</code>和<code>pop()</code>方法。<br><code>push()</code>方法可以接收任意数量的参数，将它们逐个添加到数组末尾，并返回修改后数组的长度。而<code>pop()</code>方法则从数组末尾移除最后一项，减少数组的<code>length</code>值，然后返回移除的项。</p>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>FIFO(First-In-First-Out，先进先出)，结合使用<code>shift()</code>和<code>push()</code>方法，可以像使用队列一样使用数组。<br><code>ECMAScript</code>还为数组提供了一个<code>unshift()</code>方法，它能在数组前端添加任意个项并返回新数组的长度。同时使用<code>unshift()</code>和<code>pop()</code>方法，可以从相反的方向来模拟队列。  </p>
<blockquote>
<p><code>IE7</code>及更早版本对<code>JavaScript</code>的实现中存在一个偏差，其<code>unshift()</code>方法总是返回<code>undefined</code>而不是数组的新长度。<code>IE8</code>在非兼容模式下会返回正确的长度值。  </p>
</blockquote>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><p><code>reverse()</code>反转数组项的顺序。<br><code>sort()</code>最小值位于最前面，其会调用每个数组项的<code>toString()</code>转型方法，然后比较得到的字符串，以确定如何排序。<strong>即使数组中的每一项都是数组，<code>sort()</code>方法比较的也是字符串</strong>。<br><code>sort()</code>可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。<br><strong>比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0 ，如果第一个参数应该位于第二个之后则返回一个正数。</strong> </p>
<blockquote>
<p><code>reverse()和sort()</code>方法的返回值是经过排序之后的数组。  </p>
</blockquote>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p><code>concat()</code>方法可以基于当前数组中的所有项创建一个新数组，具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。<strong>在没有给<code>concat()</code>方法传递参数的情况下，它只是复制当前的数组并返回副本。如果传递给<code>concat()</code>方法的是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾</strong>。  </p>
<p><code>slice()</code>方法，它能够基于当前数组中的一或多个项创建一个新数组。<code>slice()</code>方法可以接受一个或两个参数，即<strong>要返回项的起始位置和结束位置</strong>。在只有一个参数的情况下，<code>slice()</code>方法返回从该参数指定的位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置的项。<strong><code>slice()</code>操作并不会影响到原始数组</strong>。  </p>
<blockquote>
<p>如果<code>slice()</code>方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用<code>slice(-2, -1)</code>与调用<code>slice(3, 4)</code>得到的结果相同。如果结束为止小于起始位置，则返回空数组。  </p>
</blockquote>
<p>除此以外，<code>slice()</code>可以做到如下方法，它恐怕要算是最强大的数组方法了：</p>
<ul>
<li><strong>删除</strong>：可以删除任意数量的项，只需要指定 2 个参数：要删除的第一项的位置和要删除的项数。</li>
<li><strong>插入</strong>：可以向指定位置插入任意数量的项，只需要提供 3 个参数：起始位置、 0 （要删除的项数）和要插入的项，如果要插入多个项，可以再传入第四、第五，以至任意多个项。 </li>
<li><strong>替换</strong>：可以向指定位置插入任意数量的项，但同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的橡树和要插入的任意数量的项。<em>插入的项数不必与删除的项数相等</em>。  </li>
</ul>
<blockquote>
<p><code>slice()</code>方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。  </p>
</blockquote>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><p><code>indexOf()</code>从数组的开头开始向后查找，<code>lastIndexOf()</code>从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没有找到的情况下返回 -1.<strong>在比较时，会使用全等操作符</strong>。</p>
<blockquote>
<p><code>IE8</code>及更早版本并不支持。</p>
</blockquote>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p><code>ECMAScript 5</code>为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响<code>this</code>的值。传入这些方法中的函数会接收三个参数：<strong>数组想的值、该值在数组项中的位置和数组对象本身</strong>。  </p>
<ul>
<li><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回<code>true</code>，则返回<code>true</code>。</li>
<li><code>filter()</code>：对数组中的每一项运行给定函数，返回该函数会返回<code>true</code>的项所组成的数组。</li>
<li><code>forEach()</code>：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><code>some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回<code>true</code>，则返回<code>true</code>。  </li>
</ul>
<blockquote>
<p><code>IE8</code>及更早版本并不支持。  </p>
</blockquote>
<h4 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h4><p>缩小方法都会迭代数组的所有项，然后构建一个最终返回的值。<br><code>reduce()</code>从数组的第一项开始，<code>reduceRight()</code>从数组的最后一项开始，遍历整个数组。<br>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为<strong>缩小基础的初始值</strong>。 传给<code>reduce()</code>和<code>reduceRight()</code>的函数接收 4 个参数：<strong>前一个值、当前值、项的索引和数组对象</strong>。这个函数返回的任何值都会作为第一个参数自动传给下一项。<strong>第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</strong>  </p>
<blockquote>
<p><code>IE8</code>及更早版本并不支持。  </p>
</blockquote>
<h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a><code>Date</code>类型</h3><p>在调用<code>Date</code>构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。<strong>如果项根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数，为了简化这一计算过程，<code>ECMAScript</code>提供了两个方法：<code>Date.aprse()</code>和<code>Date.UTC()</code>。</strong><br><code>Date.parse()</code>方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数，通常所接收的为下列日期格式：</p>
<ul>
<li>“月/日/年”，如 6/13/2017;</li>
<li>“英文月名 日,年”，如 January 12,2017;</li>
<li>“英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2017 00:00:00 GMT-0700。</li>
<li>ISO 8610 扩展个事 YYYY-MM-DDTHH:mm:ss.sssZ(例如 2017-05-25T00:00:00)。<strong>只有兼容`ECMAScript 5</strong>的实现支持这种格式。  </li>
</ul>
<p><strong>如果传入<code>Date.parse()</code>方法的字符串不能表示日期，那么它会返回<code>NaN</code>。</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 以下是等价的，在直接传入构造函数的时候，也会在后台调用`Date.parse()`</div><div class="line">var someDate = new Date(Date.parse(&quot;May 25, 2017&quot;));</div><div class="line">var someDate = new Date(&quot;May 25, 2017&quot;);</div></pre></td></tr></table></figure>
<p><code>Date.UTC()</code>方法同样也返回表示日期的毫秒数，它的参数分别是年份、基于 0 的月份、月中的哪一天、小时数、分钟、秒以及毫秒数。<strong>只有前两个参数（年和月）是必须的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0.</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 以下也是等价的</div><div class="line">var y2k = new Date(Date.UTC(2017, 0));</div><div class="line">var y2k = new Date(2017, 0);</div></pre></td></tr></table></figure>
<p><code>ECMAScript 5</code>中添加了<code>Date.now()</code>方法，返回表示调用这个方法时的日期和时间毫秒数。<br>在不支持它的浏览器中，使用 + 操作符把<code>Data</code>对象转换成字符串，也可以达到同样的目的。</p>
<h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><p><code>Date</code>类型的<code>valueOf()</code>方法，则根本不返回字符串，而是返回日期的毫秒表示。<br><code>toLocaleString()</code>和<code>toString()</code>在不同浏览器下返回的日期和时间格式是不同的。  </p>
<h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><ul>
<li><code>toDateString()</code>——以特定于实现的格式显示星期几、月、日和年；</li>
<li><code>toTimeString()</code>——以特定于实现的格式显示时、分、秒和时区；</li>
<li><code>toLocaleDateString()</code>——以特定于地区的格式显示星期几、月、日和年；</li>
<li><code>toLocaleTimeString()</code>——以特定于地区实现的格式显示时、分、秒；</li>
<li><code>toUTCString()</code>——以特定于实现的格式完整的UTC日期。 </li>
</ul>
<h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a><code>RegExp</code>类型</h3><p><code>RegExp</code> = Regular Expression  正则表达式<br><code>ECMAScript</code>通过<code>RegExp</code>类型来支持正则表达式，语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var expression = / pattern / flags</div></pre></td></tr></table></figure>
<p>其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志。  </p>
<ul>
<li><code>g</code>：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li><code>i</code>：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li><code>m</code>：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
</ul>
<p>正则表达式的元字符包括：<br><code>( [ { \ ^ $ | ) ? * + . ] }</code>  </p>
<p>定义正则表达式可以使用字面量或者使用<code>RegExp</code>构造函数，使用构造函数时，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 以下两种定义方式是等价的</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure>
<p><strong>需要注意的是，传递给<code>RegExp</code>构造函数的两个参数都是字符串（不能把正则表达式字面量传递给<code>RegExp</code>构造函数）。由于<code>RegExp</code>构造函数的模式参数是字符串，所以在某些情况下要对字符进行 <em>双重转义</em> 。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如<code>\n</code>（字符<code>\</code>在字符串中通常被转义为<code>\\</code>，而在正则表达式字符串中就会变成<code>\\\\</code>）</strong> 。  </p>
<blockquote>
<p>在<code>ECMAScript 3</code>中，正则表达式字面量始终会共享同一个<code>RegExp</code>实例，而使用构造函数创建的每一个新<code>RegExp</code>实例都是一个新实例。<code>ECMAScript 5</code>明确规定，使用正则表达式字面量必须像直接调用<code>RegExp</code>构造函数一样，每次都创建新的<code>RegExp</code>实例。 <strong>——P105</strong>  </p>
</blockquote>
<h4 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a><code>RegExp</code>实例属性</h4><p><code>RegExp</code>每个实例都具有下列属性：</p>
<ul>
<li><code>global</code>：布尔值，表示是否设置了<code>g</code>标志。</li>
<li><code>ignoreCase</code>：布尔值，表示是否设置了<code>i</code>标志。</li>
<li><code>lastIndex</code>：整数，表示开始搜索下一匹配项的字符位置，从 0 算起。</li>
<li><code>multiline</code>：布尔值，表示是否设置了<code>m</code>标志。</li>
<li><code>source</code>：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。即<code>source</code>保存的是规范形式的字符串，即字面量形式所使用的字符串。</li>
</ul>
<h4 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a><code>RegExp</code>实例方法</h4><p><code>RegExp</code>对象的主要方法是<code>exec()</code>，该方法是专门为捕获组而设计的。<code>exec()</code>接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回<code>null</code>。返回的数组虽然是<code>Array</code>的实例，但是包含两个额外的属性：<code>index</code>和<code>input</code>。其中，**<code>index</code>表示匹配项在字符串中的位置，而<code>input</code>表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</p>
<blockquote>
<p>对于<code>exec()</code>方法而言，即使在模式中设置了全局标志(<code>g</code>)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用<code>exec()</code>将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用<code>exec()</code>则都会在字符串中继续查找新匹配项。此外，还应注意模式的<code>lastIndex</code>属性的变化情况，在全局匹配模式下，<code>lastIndex</code>的值在每次调用<code>exec()</code>后都会增加，而在非全局模式下始终保持不变。  </p>
</blockquote>
<p>第二个方法是<code>test()</code>，它接受一个字符串参数。在模式与该参数匹配的情况下返回<code>true</code>；否则，返回<code>false</code>。<strong>在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便</strong>。  </p>
<p><strong><code>RegExp</code>实例继承的<code>toLocaleString()</code>和<code>toString()</code>方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。</strong> </p>
<blockquote>
<p><strong>正则表达式的<code>valueOf()</code>方法返回正则表达式本身。</strong>  </p>
</blockquote>
<h4 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a><code>RegExp</code>构造函数属性</h4><p><code>RegExp</code>构造函数包含的属性基于所执行的最近一次正则表达式操作而变化。这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名（最新的是支持的，因为已经更换为了<code>webkit</code>内核））。   </p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>input</code></td>
<td>$_</td>
<td>最近一次要匹配的字符串</td>
</tr>
<tr>
<td><code>lastMatch</code></td>
<td>$&amp;</td>
<td>最近一次的匹配项</td>
</tr>
<tr>
<td><code>lastParen</code></td>
<td>$+</td>
<td>最近一次匹配的捕获组</td>
</tr>
<tr>
<td><code>leftContext</code></td>
<td>$`</td>
<td><code>input</code>字符串中<code>lastMatch</code>之前的文本</td>
</tr>
<tr>
<td><code>multiline</code></td>
<td>$*</td>
<td>布尔值，表示是否所有表达式都使用多行模式。</td>
</tr>
<tr>
<td><code>rightContext</code></td>
<td>$’</td>
<td><code>input</code>字符串中<code>lastMatch</code>之后的文本</td>
</tr>
</tbody>
</table>
<blockquote>
<p>虽然长属性名都可以使用短属性名来代替，只不过，由于这些短属性名大都不是有效的<code>ECMAScript</code>标识符，因此必须通过方括号语法来访问它们。<strong>除此之外，还有多达 9 个用于存储捕获组的构造函数属性，访问这些属性的语法是：<code>RegExp.$1</code>、<code>RegExp.$2</code>…<code>RegExp.$9</code>分别用于存储第一、第二……第九个匹配的捕获组，在调用 <em><code>exec()</code>或<code>test()</code></em> 方法时，这些属性都会被自动填充</strong>。  </p>
<p>关于模式的局限性，请查阅 <strong>——P109</strong>  </p>
<p>更多关于正则表达式的信息，请查阅<a href="http://www.regular-expressions.info/" target="_blank" rel="external">regular-expressions.info</a></p>
</blockquote>
<h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a><code>Function</code>类型</h4><p>函数实际上是对象，每个函数都是<code>Function</code>类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此<strong>函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定</strong>。  </p>
<p>三种定义函数的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function sum (num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var sum = function(num1, num2) &#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;); //不推荐</div></pre></td></tr></table></figure></p>
<p>第三种从技术角度讲，是一个函数表达式，并不推荐，因为这种语法会导致解析两次代码（第一次是解析常规`ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。</p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a><strong>没有重载</strong></h4><h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h4><p><strong>解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行</strong>。  </p>
<p><strong>函数声明提升（function declaration hoisting）</strong>：<code>JavaScript</code>引擎在第一遍会声明函数并将它们放到源代码树的顶部。</p>
<h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>因为<code>ECMAScript</code>中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。  </p>
<h4 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h4><p>在函数内部，有两个特殊的对象：<code>arguments</code>和<code>this</code>。<br><code>arguments</code>是一个类数组对象，包含着传入函数中的所有参数。虽然<code>arguments</code>的主要用途是保存函数参数，但这个对象还有一个名叫<code>callee</code>的属性，该属性是一个指针，指向拥有这个<code>arguments</code>对象的函数。<br><strong>使用<code>arguments.callee</code>可以消除函数的执行与函数名耦合的问题。 ——P114</strong>  </p>
<p>函数内部的另一个特殊对象是<code>this</code>，<code>this</code>引用的是函数<strong>据以执行的环境对象</strong>。</p>
<blockquote>
<p>函数的名字仅仅是一个包含指针的变量而已。  </p>
</blockquote>
<p><code>ECMAScript 5</code>也规范化了另一个函数对象的属性：<code>caller</code>，这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，他的值为<code>null</code>。也可以通过<code>arguments.callee.caller</code>来访问相同的信息。  </p>
<blockquote>
<p>在严格模式下，访问<code>arguments.callee</code>会导致错误。<code>ECMAScript 5</code>还定义了<code>arguments.caller</code>属性，但在严格模式下访问它也会导致错误，<strong>而在非严格模式下这个属性始终为<code>undefined</code></strong>。定义这个属性是为了分清<code>arguments.caller</code>和函数的<code>caller</code>属性。<strong>严格模式下不能为函数的<code>caller</code>属性赋值，否则会导致错误。</strong>  </p>
</blockquote>
<h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4><p>每个函数都包含两个属性<code>length</code>和<code>prototype</code>，其中<strong><code>length</code>属性表示函数希望接收的命名参数的个数</strong>。<br><strong>对于<code>ECMAScript</code>中的引用类型而言，<code>prototype</code>是保存它们所有实例方法的真正所在。在创建自定义引用类型以及实现继承时，<code>prototype</code>属性是极为重要的。在<code>ECMAScript 5</code>中，<code>prototype</code>属性是不可枚举的</strong>。  </p>
<p>每个函数都包含两个非继承而来的方法：<code>apply()</code>和<code>call()</code>。<strong>这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内<code>this</code>对象的值</strong>。<br><code>apply()</code>接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。<strong>第二个参数可以是<code>Array</code>的实例，也可以是<code>arguments</code>对象</strong>  </p>
<blockquote>
<p>？在严格模式下，未指定环境对象而调用函数，则<code>this</code>值不会转型为<code>window</code>。除非明确把函数添加到某个对象或者调用<code>apply()</code>或<code>call()</code>，否则<code>this</code>值将是<code>undefined</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;</div><div class="line"></div><div class="line">function sum(num1, num2)&#123;</div><div class="line">  console.log(this);</div><div class="line">  return num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum1(num1, num2) &#123;</div><div class="line">  return sum.apply(this, arguments);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function callSum2(num1, num2) &#123;</div><div class="line">  return sum.apply(this, [num1, num2]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(sum(10, 10));</div><div class="line">console.log(callSum1(10, 10));</div><div class="line">console.log(callSum2(10, 10));</div></pre></td></tr></table></figure></p>
</blockquote>
<p>在严格模式下会输出以下结果：<br><img src="/2017/08/17/JavaScript引用类型/严格模式.png" alt=""></p>
<p>而在非严格模式下会输出以下结果：<br><img src="/2017/08/17/JavaScript引用类型/非严格模式.png" alt="">  </p>
<blockquote>
<p>（测试环境在<code>Node</code>下，所以不会打印出<code>window</code>对象而是<code>global</code>对象，当使用<code>Chrome</code>开发者工具进行测试时会打印出<code>window</code>对象）  </p>
</blockquote>
<p><code>call()</code>方法与<code>apply()</code>方法的作用相同，它们的区别仅仅在于接收参数的方式不同。对于<code>call()</code>方法而言，第一个参数是<code>this</code>值没有变化，<strong>变化的是其余参数都直接传递给函数，即在使用<code>call()</code>方法时，传递给函数的参数必须逐个列举出来</strong>。  </p>
<blockquote>
<p>如果你打算直接传入<code>arguments</code>对象，或者包含函数中先接收到的也是一个数组，那么使用<code>apply()</code>肯定更方便，否则使用<code>call()</code>更合适。  </p>
<p><code>apply()</code>和<code>call()</code>真正强大的地方是能够扩充函数赖以运行的作用域，使用<code>call()</code>（或<code>apply()</code>）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。<strong><code>ECMAScript 5</code>中还定义了一个<code>bind()</code>方法，这个方法会创建一个函数的实例，其<code>this</code>值会被绑定到传给<code>bind()</code>函数的值。</strong>  </p>
<p>每个函数继承的<code>toLocaleString()</code>和<code>toString()</code>方法始终都返回函数的代码。<code>valueOf()</code>方法同样也只返回函数代码。  </p>
</blockquote>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p><strong>引用类型与基本包装类型的主要区别就是对象的生存期。使用<code>new</code>操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则在存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</strong>  </p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a><code>Boolean</code>类型</h4><blockquote>
<p>永远不要使用<code>Boolean</code>对象。</p>
</blockquote>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a><code>Number</code>类型</h4><p><code>Number</code>类型提供了一些用于将数值格式化为字符串的方法。其中<code>toFixed()</code>方法会按照指定的小数位返回数值的字符串表示。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入。  </p>
<blockquote>
<p>不同浏览器给这个方法设定的舍入规则可能会有所不同，在给<code>toFixed()</code>传入 0 的情况下，<code>IE8</code>及之前版本不能正确舍入范围在<code>{(-0.94,-0.5],[0.5,0.94)}</code>之间的值。对于这个范围内的值，<code>IE</code>会返回 0 ，而不是 -1 或 1；其他浏览器都能返回正确的值。<code>IE9</code>修复了这个问题。</p>
</blockquote>
<p><code>toExponential()</code>返回指数表示法（也称之为 e 表示法），表示的数值的字符串形式。与<code>toFixed()</code>一样，<code>toExponential()</code>也接收一个参数，而且该参数同样也是指定输出结果中的小数位数。<br>对于一个数值来说，<code>toPrecision()</code>方法可能会返回固定大小（<code>fixed</code>）格式，也可能返回指数（<code>exponential</code>)格式，该方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。 </p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><code>String</code>类型</h4><blockquote>
<p><code>String</code>类型的每个实例都有一个<code>length</code>属性，表示字符串中包含多个字符，应该注意的是，<strong>即使字符串中包含双字节字符，每个字符也仍然算一个字符</strong>。  </p>
</blockquote>
<h5 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h5><p>两个用于访问字符串中特定字符的方法是<code>charAt()</code>和<code>charCodeAt()</code>，这两个方法都接收一个参数，即基于 0 的字符位置。其中，<code>charAt()</code>方法以单字符字符串的形式返回给定位置的那个字符（<code>ECMAScript</code>中没有字符类型）。如果想得到当前给定位置的单个字符的字符编码，就需要使用<code>charCodeAt()</code>。  </p>
<blockquote>
<p>使用方括号访问个别字符的语法得到了<code>IE8+</code>等浏览器的支持，但在<code>IE7</code>及更早的版本中使用这种语法，会返回<code>undefined</code>值。  </p>
</blockquote>
<h5 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h5><p><code>concat()</code>将一或多个字符串拼接起来，返回拼接得到的新字符串。<strong>实际中使用加号操作符（+）更常见</strong>  </p>
<p><code>ECMAScript</code>还提供了三个基于字符串创建新字符串的方法：<code>slice()</code>、<code>substr()</code>和<code>substring()</code>。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一个或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，<code>slice()</code>和<code>substring()</code>的第二个参数指定的是子字符串最后一个字符后面的位置。而<code>substr()</code>的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。**与<code>concat()</code>方法一样，<code>slice()</code>、<code>substr()</code>和<code>substring()</code>也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。  </p>
<h5 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h5><p>从字符串中查找子字符串的方法：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置（<strong>如果没有找到，则返回 -1</strong>）。</p>
<h5 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a><code>trim()</code>方法</h5><p><code>ECMAScript 5</code>为所有字符串定义了<code>trim()</code>方法，这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。  </p>
<blockquote>
<p><code>IE9+</code>支持，详情查看 <a href="http://caniuse.com/#search=trim" target="_blank" rel="external">Can I use</a>  </p>
</blockquote>
<h5 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h5><p><code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>、<code>toLocaleUpperCase()</code>。<strong>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥</strong>  </p>
<h5 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h5><p><code>match()</code>与调用<code>RegExp</code>的<code>exec()</code>方法相同。<br><code>search()</code>这个方法的唯一参数与<code>match()</code>方法的参数相同：由字符串或<code>RegExp</code>对象指定的一个正则表达式。<code>search()</code>方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回 -1 。  </p>
<p><code>replace()</code>方法，接受两个参数：第一个参数可以是一个<code>RegExp</code>对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以使一个字符串或者一个函数。<strong>如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的办法是提供一个正则表达式，而且要指定全局（g）标志。<br><code>replace()</code>方法的第二个参数也可以是一个函数，在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递 3 个参数：</strong>模式的匹配项、模式匹配项在字符串中的位置和原始字符串<strong>。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是 </strong>模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原是字符串**。  </p>
<p><code>split()</code>方法可以基于指定的分隔符将一个字符串分割成多个字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个<code>RegExp</code>对象（这个方法不会将字符串看成正则表达式），<strong><code>split()</code>可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小</strong>。  </p>
<h5 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a><code>localeCompare()</code>方法</h5><p>此方法用于比较两个字符串，并返回下列值中的一个：</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是 -1，具体的值要视实现而定）；</li>
<li>如果字符串等于字符串参数，则返回 0；</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的值同样要视实现而定）；  </li>
</ul>
<blockquote>
<p><code>localeCompare()</code>方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。  </p>
</blockquote>
<h5 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a><code>fromCharCode()</code>方法</h5><p>静态方法，用于接收一或多个字符编码，然后将它们转换成一个字符串。 与<code>charCodeAt()</code>执行的是相反的操作。  </p>
<h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><p><code>ECMA-262</code>对内置对象的定义是：”由<code>ECMAScript</code>实现提供的、不依赖于宿主环境的对象，这些对象在<code>ECMAScript</code>程序执行之前就已经存在了。”也就是说，不必显式地实例化内置对象，因为它们已经实例化了。除了<code>Object</code>、<code>Array</code>和<code>String</code>，<code>ECMA-262</code>还定义了两个单体内置对象：<code>Global</code>和<code>Math</code>。    </p>
<h4 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a><code>Global</code>对象</h4><p><code>Global</code>全局对象在某种意义上是作为一个终极的“兜底儿对象”，其不属于任何其他对象的属性和方法，最终都是它的属性和方法。<strong>事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是<code>Global</code>对象的属性</strong>。除了诸如<code>isNaN() | isFinite() | parseInt() | parseFloat()</code>外，还包括：  </p>
<h5 id="URI编码方法"><a href="#URI编码方法" class="headerlink" title="URI编码方法"></a><code>URI</code>编码方法</h5><p><code>encodeURI()</code>和<code>encodeURIComponent()</code>方法可以对<code>URI</code>进行编码，它们用特殊的<strong>UTF-8</strong>编码替换所有无效的字符，从而让浏览器能够接受和理解。<br><code>encodeURI()</code>主要用于整个URI，而<code>encodeURIComponent()</code>主要用于对URI中的某一段进行编码。主要区别是：<strong><code>encodeURI()</code>不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而<code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码</strong>。  </p>
<blockquote>
<p>一般来说，我们使用<code>encodeURIComponent()</code>方法的时候要比用<code>encodeURI()</code>更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。  </p>
</blockquote>
<p>与<code>encodeURI()</code>和<code>encodeURIComponent()</code>方法对应的两个方法分别是<code>decodeURI()</code>和<code>decodeURIComponent()</code>。  </p>
<h5 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a><code>eval()</code>方法</h5><p>当解析器发现代码中调用<code>eval()</code>方法时，它会将传入的参数当做实际的<code>ECMAScript</code>语句来解析，然后把执行结果插入到原位置。通过<code>eval()</code>执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链，这就意味着通过<code>eval()</code>执行的代码可以引用在包含环境中定义的变量。<br><strong>在<code>eval()</code>中创建的任何变量和函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们旨在<code>eval()</code>执行的时候创建。严格模式下，在外部访问不到<code>eval()</code>中创建的任何变量和函数</strong>。  </p>
<h5 id="Global对象的属性"><a href="#Global对象的属性" class="headerlink" title="Global对象的属性"></a><code>Global</code>对象的属性</h5><p><img src="/2017/08/17/JavaScript引用类型/Global对象的属性.png" alt="">  </p>
<h5 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a><code>window</code>对象</h5><p><code>Web</code>浏览器都是将<code>Global</code>这个全局对象作为<code>window</code>对象的一部分加以实现的，因此在全局作用域中声明的所有变量和函数，都成为了<code>window</code>对象的属性。  </p>
<h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a><code>Math</code>对象</h4><h5 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a><code>Math</code>对象的属性</h5><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.E</td>
<td>自然对数的底数，即常量 e 的值</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10 的自然对数</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2 的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以 2 为底 e 的对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以 10 为底 e 的对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>π 的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2 的平方根（即2的平方根的倒数）</td>
</tr>
<tr>
<td>Math.SQRT2</td>
<td>2 的平方根</td>
</tr>
</tbody>
</table>
<h5 id="min-和max-方法"><a href="#min-和max-方法" class="headerlink" title="min()和max()方法"></a><code>min()</code>和<code>max()</code>方法</h5><p>用于确定一组数值中的最小值和最大值，这两个方法都可以接收任意多个数值参数。<br>要找到数组中的最大值或最小值，可以像下面这样使用<code>apply()</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [1, 2, 3, 4, 5, 6, 7, 8];</div><div class="line">var max = Math.max.apply(Math, values);</div><div class="line">var min = Math.min.apply(Math, values);</div></pre></td></tr></table></figure></p>
<h5 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h5><ul>
<li><code>Math.ceil()</code>向上舍入</li>
<li><code>Math.floor()</code>向下舍入</li>
<li><code>Math.round()</code>标准舍入（四舍五入）</li>
</ul>
<h5 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a><code>random()</code>方法</h5><p><code>Math.random()</code>返回介于 0 和 1 之间的一个随机数，不包括 0 和 1.</p>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p><img src="/2017/08/17/JavaScript引用类型/Math中的其他方法.png" alt="">  </p>

	
	
	
	
</div>
				
				

                <!-- Post Comments -->
                
    <!-- 使用多说评论 -->
    <link rel="stylesheet" href="/css/duoshuo.min.css">
<style>
    #ds-thread #ds-reset .ds-post-button{
        background-color: #0097A7 !important;
    }
    #ds-wrapper #ds-reset .ds-icons-32{
        background-color: #0097A7 !important;
    }
    #ds-reset .ds-highlight {
        color: #0097A7 !important;
    }
</style>
<div id="comments">
    <!-- 多说评论框 start -->
        <div class="ds-thread" 
            data-thread-key="2017/08/17/JavaScript引用类型/" 
            data-url="https://jackerjay.github.io/2017/08/17/JavaScript引用类型/"
            data-title="JavaScript引用类型"></div>
    <!-- 多说评论框 end -->
</div>



            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/08/13/JavaScript变量、作用域和内存问题/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>
        </div>
    </div>

				
				
					<!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay "></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored  sidebar-fixed-left" role="navigation">
	<div id="sidebar-main">
	    <!-- Sidebar Header -->
		<div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
    <i class="material-icons">clear_all</i>
    <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="JackerJay's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        jackerjay@hotmail.com
        <b class="caret"></b>
    </a>
</div>

		<!-- Sidebar Navigation  -->
		<ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
			
                <li>
                    <a href="#" target="_blank" title="Email Me">
						<i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    <li id="sidebar-first-li">
        <a href="/" target="_self">
            <i class="material-icons sidebar-material-icons">home</i>
             主页
        </a>
    </li>

    <!-- I'm Feeling Lucky -->
<!--
    <li class="dropdown">
        <a href="" target="_self">
            <i class="material-icons sidebar-material-icons">explore</i>
             sidebar.imlucky
        </a>
    </li>
-->

	
    <!-- Archives  -->
    <li class="dropdown">
        <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
            <i class="material-icons sidebar-material-icons">inbox</i>
             归档
            <b class="caret"></b>
        </a>
        <ul class="dropdown-menu">
            <li>
            <a class="sidebar_archives-link" href="/archives/2017/08/">八月 2017<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/03/">三月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/02/">二月 2017<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/12/">十二月 2016<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/11/">十一月 2016<span class="sidebar_archives-count">4</span></a>
        </ul>
    </li>

    <!-- Divider -->
    <li class="divider"></li>


    <!-- Pages  -->
	

    <!-- Article Numebr  -->
    <li>
        <a href="/archives">
             文章总数
             <span class="sidebar-badge">20</span>
        </a>
    </li>
</ul>

		<!-- Sidebar Divider -->
		<div class="sidebar-divider"></div>

		<!-- Sidebar Footer -->
		<!-- 
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持。 :) 
-->

<!-- Theme Material -->
<a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
	<div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
		主题 - Material
		<span class="sidebar-badge badge-circle">i</span>
	</div>
</a>

<!-- Help & Support -->
<!--
<a href="mailto:hiviosey@gmail.com" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
		sidebar.help
		<span class="mdl-button__ripple-container">
			<span class="mdl-ripple"></span>
		</span>
	</div>
</a>
-->

<!-- Feedback -->
<!--
<a href="https://github.com/viosey/hexo-theme-material/issues" target="_blank" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
         sidebar.feedback
                    <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
</a>
-->

<!-- Abount Theme -->
<!--
<a href="https://blog.viosey.com/index.php/Material.html" target="_blank" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
         sidebar.about_theme
        <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
</a>-->

	</div>
    
    <!-- Sidebar Sponsor -->
    


</aside>

				
				
				
					<!-- Footer Top Button -->
					<div class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>
				
				
				<!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
	
	
		<!-- Paradox Footer Left Section -->
		<div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
    
    
    <!-- Facebook -->
    
    
    
    <!-- Google + -->
    
    
    
    <!-- Weibo -->
    
    
    
    <!-- Instagram -->
    
    
    
    <!-- Tumblr -->
    
    
    
    <!-- Github -->
    
    <a href="http://github.com/jackerjay" target="view_window"><button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-github.png);">
        <span class="visuallyhidden">Github</span>
    </button></a>
    
</div>


		<!--Copyright-->
		<div id="copyright">Copyright&nbsp;©&nbsp;<script type="text/javascript">var fd = new Date();document.write(fd.getFullYear());</script>&nbsp;JackerJay杂记</div>

		<!-- Paradox Footer Right Section -->

		<!-- 
		I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright.
		It will not impact the appearance and can give developers a lot of support :)

		很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
		它不会影响美观并可以给开发者很大的支持。 :) 
		-->

		<div class="mdl-mini-footer--right-section">
			<div>
				<div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
				<div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
			</div>
		</div>
	
    
</footer>
                
				<!-- Import File -->
<script src="/js/highlight.min.js"></script>
<script src="/js/js.min.js"></script>
<script src="/js/nprogress.js"></script>

<script type="text/javascript">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    
    $('#nprogress .bar').css({
        'background': '#FF4081'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #FF4081, 0 0 15px #FF4081'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#FF4081',
        'border-left-color': '#FF4081'
    });
    
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>








    <!-- 多说公共 js 代码 start -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"null"};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = 'https://static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] 
             || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共 js 代码 end -->




<!-- Swiftye -->


<!-- Local Search-->


<!-- Window Load-->
<script>
    $(window).load(function() {
        // Post_Toc parent position fixed
        $(".post-toc-wrap").parent(".mdl-menu__container").css("position", "fixed");
    });
</script>

<!-- MathJax Load-->

            </main>
        </div>
		
    </body>
		
	
</html>
